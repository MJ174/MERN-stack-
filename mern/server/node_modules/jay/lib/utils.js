var fs = require('fs'),
    read = fs.readFileSync,
    path = require('path'),
    extname = path.extname,
    dirname = path.dirname,
    join = path.join;

exports.bind = function __bind(fn, me) {
  return function() { return fn.apply(me, arguments); };
};

var escapeJSON = exports.escapeJSON = function(json) {
  var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      meta = { // table of character substitutions
              '\b': '\\b',
              '\t': '\\t',
              '\n': '\\n',
              '\f': '\\f',
              '\r': '\\r',
              '"' : '\\"',
              '\\': '\\\\'
            };

  escapable.lastIndex = 0;
  return escapable.test(json) ? '"' + json.replace(escapable, function (a) {
      var c = meta[a];
      return (typeof c === 'string') ? c
        : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
  }) + '"' : '"' + json + '"';

};

/**
 * Resolve the file path
 *
 * @param  {string} req
 * @param  {string} src
 * @api private
 * @return {str}
 */

var resolve = exports.resolve = function(req, root, src) {
  var deps;

  if(req[0] === '/' || !src) {
    req = (!extname(req)) ? req + '.js' : req;
    return join(root, req);
  } else if(/^\.\//.test(req) || /^\.{2}/.test(req)) {
    req = (!extname(req)) ? req + '.js' : req;
    return join(dirname(src), req);
  } else {
    var dir = dirname(src),
        isRoot = (dir == root);

    try {
      deps = require(join(dir, 'component.json')).dependencies;
    } catch(e) {
      console.error("Couldn't find ", join(dir, 'component.json'), "for components");
      return '';
    }

    var dep = findDependency(req, deps);

    if(!dep) {
      console.error("Couldn't find ", dep, "skipping for now");
      return '';
    }

    dep = dep.replace('/', '-');
    var depdir = join(root, 'components', dep);

    try {
      deps = require(join(depdir, 'component.json'));
    } catch(e) {
      console.error("Couldn't find ", join(depdir, 'component.json'), "for components");
      return '';
    }

    if(deps.main) {
      return join(depdir, deps.main);
    } else {
      return join(depdir, 'index.js');
    }

  }
};

/**
 * Relativize the js/css keys before wrapping
 *
 * @param  {object} obj
 * @api private
 * @return {object}
 */

var relativize = exports.relativize = function(obj, root) {

  Object.keys(obj).forEach(function(key) {
    obj[key.replace(root, '')] = obj[key];
    delete obj[key];
  });

  return obj;
};

/**
 * Figure out which path exists, returns first
 * path in the list that exists.
 *
 * @param  {array}   paths
 * @param  {function} fn
 * @api private
 */

var which = exports.which = function(paths, fn) {
  var pending = paths.length,
      out = [];

  paths.forEach(function(path, i) {
    fs.exists(path, function(exists) {
      if(!exists) out[i] = false;
      else out[i] = path;
      if(!--pending) return done();
    });
  });

  function done() {
    var len = out.length;
    for(var i = 0; i < len; i++)
      if(out[i] !== false) return fn(null, out[i]);
    return fn(null, false);
  }
};

/*
  Step - tiny, but flexible step library

  Usage:

    var first = function(next) {
      ...
      return next(null, name, date);
    }

    var second = function(err, name, date, next) {
      ...
      return next(null, person);
    }

    var last = function(err, person) {
      ...
    }

    step(first, second, last);
*/

var step = exports.step = function() {
  var slice = Array.prototype.slice,
      stack = slice.call(arguments).reverse(),
      self  = this;

  function next(err) {
    // Jump to last func if error occurs
    if(err) return stack[0].call(self, err);

    // Otherwise gather arguments and add next func to end
    var args = slice.call(arguments);

    if(stack.length > 1) args.push(next);

    // Call the next function on the stack with given args
    stack.pop().apply(self, args);
  }

  // Kick us off
  stack.pop().call(self, next);
};

/**
 * Find dependency
 */

function findDependency(component, dependencies) {
  var reg = new RegExp(".+\/" + component);

  for(var dep in dependencies) {
    if(reg.test(dep)) return dep;
  }

  return false;
}
