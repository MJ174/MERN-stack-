/**
 * Module dependencies
 */

var fs = require('fs'),
    path = require('path'),
    join = path.join,
    extname = path.extname,
    basename = path.basename,
    dirname = path.dirname,
    relative = path.relative,
    mkdirp = require('mkdirp'),
    utils = require('./utils'),
    which = utils.which,
    relativize = utils.relativize,
    resolve = utils.resolve,
    step = utils.step,
    Batch = require('batch'),
    compilers = require('./compilers'),
    wrapper = require('./wrap'),
    detective = require('detective'),
    deputy = require('deputy2');

/**
 * Private API
 */

/**
 * Initialize a `jay` instance
 * @param {function} engine
 * @api private
 */

var init = exports.init = function(engine) {

  // Slide through if we're in production
  if(process.env.NODE_ENV === 'production') return engine;

  if(!this._root) throw new Error('jay requires a root to be specified');

  // Home directory
  var home = process.env.HOME || process.env.USERPROFILE;

  // Directory setup
  this._build = this._build || join(this._root, 'build');
  this._cache = this._cache || '.jay/cache.json';

  // Set up deputy unless we turn off caching
  this.detective = (this._cache !== false)
                    ? deputy(join(home, this._cache))
                    : detective;

  // Set up the js and css objects
  this.js = {};
  this.css = {};

  // Render engine
  this.engine = engine || function() {};

  // Set up the includes
  this.includes = this.includes || [];

  // Set up the boots
  this.boots = this.boots || [];

  // Set up the dirs
  this.dirs = this.dirs || [];

  // Bind `out` to `this`
  return out.bind(this);
};



/**
 * Output the results
 * @param  {function} fn
 * @api private
 */

var out = exports.out = function(path, locals, fn) {
  locals = locals || {};
  fn = fn || function() {};
  if(typeof locals === 'function') {
    fn = locals;
    locals = {};
  }

  this._main = path;

  var self = this,
      batch = new Batch(),
      root = this._root,
      rel = relative(this._root, dirname(this._main));

  // Update the build path
  var build = this._builddir = join(this._build, rel);

  // Add mkdir to the batch
  batch.push(function(done) {
    mkdirp(build, done);
  });

  // bind the functions
  var walk = this.walk.bind(this),
      wrap = this.wrap.bind(this),
      write = this.write.bind(this);

  // Resolve the boots
  var boots = this.boots.map(function(boot) {
    return join(dirname(path), boot);
  });

  // Add any boot files in front, always adding view + .js
  boots = boots.concat(path.replace(extname(path), '.js'));

  // Determine which boot to use and walk it
  batch.push(function(done) {
    which(boots, function(err, boot) {
      if(err) return fn(err);
      self._boot = boot;
      walk(boot, done);
    });
  });

  // Resolve includes
  var includes = this.includes.map(function(include) {
    return resolve(include, root);
  }, this);

  // Add walk the includes to the batch
  includes.forEach(function(include) {
    batch.push(function(done) {
      walk(include, done);
    });
  });

  batch.end(function(err) {
    if(err) {
      if(err.code === 'ENOENT') {
        console.error('Jay:', err);
        return self.engine(path, locals, fn);
      } else return fn(err);
    }

    step(wrap, write, function(err) {
      if(err) return fn(err);

      // console.log(((new Date()).getTime() - start) + ' ms');
      return self.engine(path, locals, fn);
    });
  });


};

/**
 * Walk up and down the javascript requires
 * @param  {string}   src
 * @param  {function} done
 * @api private
 */

var walk = exports.walk = function(src, fn) {
  var self = this,
      aliases = this.aliases || {},
      detective = this.detective,
      isRoot = (dirname(src) == self._root),
      reqs;

  // Covers views that don't require jay, (ie. basic login)
  if(!src) return fn(null);

  // Read in the source and add it
  fs.readFile(src, 'utf8', function(err, str) {
    if(err) return fn(err);
    var compiler = compilers[extname(src).substring(1)];
    console.log(src);
    // Add it
    self.js[src] = (compiler) ? compiler.call(self, str, src) : str;
    if(!self.js[src]) delete self.js[src];

    try {
      reqs = detective(str);
    } catch(e) {
      return fn('Jay: Javascript error!\n\n' + e.message);
    }

    var pending = reqs.length;
    if(!pending) return fn(null);

    reqs.forEach(function(req) {
      req = (aliases[req]) ? aliases[req] : req;

      // Resolve the pathname
      var res = resolve(req, self._root, src);
      // console.log(isRoot, req, res);
      self.alias(req, res.replace(self._root, ''));

      // If we already have it, fuggetuhboutit
      if(!res || self.js[res]) return next();

      // Build it
      walk.call(self, res, next);
    });

    function next(err) {
      if(err) return fn(err);
      if(!--pending) return fn(null);
    }

  });
};

/**
 * Wrap our objects in `require`
 * @param  {error|string} err
 * @api private
 */

var wrap = exports.wrap = function(fn) {
  var root = this._root,
      main = this._boot,
      js = relativize(this.js, root),
      css = relativize(this.css, root);

  js = wrapper.js(js, this.aliases);
  if(main) js += '\nrequire("' + main.replace(root, '') + '");\n';
  css = wrapper.css(css);

  return fn(null, js, css);
};

/**
 * Write the javascript and css to the build directory
 * @param  {error}   err
 * @param  {function} fn
 * @api private
 */

var write = exports.write = function(err, js, css, fn) {
  var build = this._builddir,
      pending = 2;

  var js_stream = fs.createWriteStream(join(build, 'jay.js')),
      css_stream = fs.createWriteStream(join(build, 'jay.css'));

  js_stream.write(js);
  css_stream.write(css);

  js_stream.end(done);
  css_stream.end(done);

  function done(err) {
    if(err) return fn(err);
    else if(!--pending) return fn(null);
  }
};

/**
 * Public API
 */

/**
 * Create a `jay` instance
 * @api public
 * @returns {object} jay
 */

var create = exports.create = function() {
  var jay = function() { return init.apply(jay, arguments); };

  // Inherit from `exports`
  jay.__proto__ = exports;

  return jay;
};

/**
 * Include additional modules
 * @param  {string} alias
 * @param {string} path
 * @api public
 * @return {object} jay
 */

var include = exports.include = function(alias, path) {
  if(!alias) return this;
  if(!this.includes) this.includes = [];

  // Set up alias if alias & path are specified
  if(path) {
    if(!this.aliases) this.aliases = {};
    this.aliases[alias] = path;
  } else {
    path = alias;
  }

  this.includes.push(path);
  return this;
};

/**
 * Alias a module
 * @param  {string} to
 * @param  {string} from
 * @api public
 * @return {object} jay
 */

var alias = exports.alias = function(to, from) {
  if(!to || !from) return this;
  if(!this.aliases) this.aliases = {};
  this.aliases[to] = from;
  return this;
};

/**
 * Set the main directory
 * @param {string} main
 * @api public
 * @return {object} jay
 */

var main = exports.main = function(main) {
  if(!this.boots) this.boots = [];
  this.boots.push(main);
  return this;
};

/**
 * Set the root directory
 * @param  {string} root
 * @api public
 * @return {object} jay
 */

var root = exports.root = function(root) {
  this._root = root;
  return this;
};

/**
 * Set the build directory
 * @param  {string} build
 * @api public
 * @return {object} jay
 */

var build = exports.build = function(build) {
  this._build = build;
  return this;
};

/**
 * Set the cache directory, or no cache if false
 * @param  {string|boolean} cache
 * @api public
 * @return {object} jay
 */

var cache = exports.cache = function(cache) {
  this._cache = cache;
  return this;
};

/**
 * Set additional directories to load modules from
 */

var dir = exports.dir = function(dir) {

};

/**
 * Export the version
 */

exports.version = require('../package.json').version;

/**
 * Export an instance of `jay`
 */

module.exports = create();

